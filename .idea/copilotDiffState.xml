<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/1. Introduction/templates/FunctionalWorkflowTemplate.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/1. Introduction/templates/FunctionalWorkflowTemplate.md" />
              <option name="originalContent" value="# Major Functionalities &amp; Workflows&#10;&#10;## Major Functionalities&#10;&#10;| Functionality Name | Description                                      | Main Classes/Endpoints          |&#10;|--------------------|--------------------------------------------------|---------------------------------|&#10;|&#10;&#10;## User/Client Workflows&#10;&#10;| Workflow Name       | Description                                      | Main Classes/Endpoints          |&#10;|---------------------|--------------------------------------------------|---------------------------------|&#10;|                     |                                                  |                                 |&#10;&#10;## Scheduled/Bulk Jobs&#10;&#10;| Job Name            | Schedule/Trigger                                 | Responsible Class/Service       |&#10;|---------------------|--------------------------------------------------|---------------------------------|&#10;|                     |                                                  |                                 |&#10;&#10;## Detailed Workflow Descriptions&#10;&#10;### Workflow: [Name]&#10;- **Start Point(s):**&#10;- **Supporting Classes/Services:**&#10;- **Database/External Calls:**&#10;- **Diagram:** (optional: link or paste below)&#10;" />
              <option name="updatedContent" value="# Major Functionalities &amp; Workflows&#10;&#10;## Major Functionalities&#10;&#10;| Functionality Name | Description                                      | Main Classes/Endpoints          |&#10;|--------------------|--------------------------------------------------|---------------------------------|&#10;|&#10;&#10;## User/Client Workflows&#10;&#10;| Workflow Name       | Description                                      | Main Classes/Endpoints          |&#10;|---------------------|--------------------------------------------------|---------------------------------|&#10;|                     |                                                  |                                 |&#10;&#10;## Scheduled/Bulk Jobs&#10;&#10;| Job Name            | Schedule/Trigger                                 | Responsible Class/Service       |&#10;|---------------------|--------------------------------------------------|---------------------------------|&#10;|                     |                                                  |                                 |&#10;&#10;## Detailed Workflow Descriptions&#10;&#10;### Workflow: [Name]&#10;- **Start Point(s):**&#10;- **Supporting Classes/Services:**&#10;- **Database/External Calls:**&#10;- **Diagram:** (optional: link or paste below)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/2. Setup/application-design/E-Commerce-Platform-Design.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/2. Setup/application-design/E-Commerce-Platform-Design.md" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/pom.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.1.2&lt;/version&gt;&#10;        &lt;relativePath/&gt;&#10;    &lt;/parent&gt;&#10;&#10;    &lt;groupId&gt;com.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;e-commerce-service&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;e-commerce-service&lt;/name&gt;&#10;    &lt;description&gt;Complex E-Commerce Service for Testing Demonstration&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;17&lt;/java.version&gt;&#10;        &lt;testcontainers.version&gt;1.18.3&lt;/testcontainers.version&gt;&#10;        &lt;spring-cloud.version&gt;2022.0.3&lt;/spring-cloud.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Core Spring Boot --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Database --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;&#10;            &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Cache --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Search --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Messaging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Documentation --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;&#10;            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;&#10;            &lt;version&gt;2.1.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Utilities --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;optional&gt;true&lt;/optional&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;            &lt;version&gt;0.11.5&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;            &lt;version&gt;0.11.5&lt;/version&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;            &lt;version&gt;0.11.5&lt;/version&gt;&#10;            &lt;scope&gt;runtime&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Testing Dependencies --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;&#10;            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.mockito&lt;/groupId&gt;&#10;            &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;dependencyManagement&gt;&#10;        &lt;dependencies&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;&#10;                &lt;artifactId&gt;testcontainers-bom&lt;/artifactId&gt;&#10;                &lt;version&gt;${testcontainers.version}&lt;/version&gt;&#10;                &lt;type&gt;pom&lt;/type&gt;&#10;                &lt;scope&gt;import&lt;/scope&gt;&#10;            &lt;/dependency&gt;&#10;        &lt;/dependencies&gt;&#10;    &lt;/dependencyManagement&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;excludes&gt;&#10;                        &lt;exclude&gt;&#10;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;                        &lt;/exclude&gt;&#10;                    &lt;/excludes&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/ECommerceApplication.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/ECommerceApplication.java" />
              <option name="updatedContent" value="package com.example.ecommerce;&#10;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.cache.annotation.EnableCaching;&#10;import org.springframework.scheduling.annotation.EnableScheduling;&#10;&#10;@SpringBootApplication&#10;@EnableCaching&#10;@EnableScheduling&#10;public class ECommerceApplication {&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(ECommerceApplication.class, args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/config/SecurityConfig.java" />
              <option name="updatedContent" value="package com.example.ecommerce.config;&#10;&#10;import com.example.ecommerce.security.JwtAuthenticationFilter;&#10;import com.example.ecommerce.security.JwtAuthorizationFilter;&#10;import com.example.ecommerce.service.UserService;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableMethodSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final UserService userService;&#10;    private final JwtAuthorizationFilter jwtAuthorizationFilter;&#10;&#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .cors().configurationSource(corsConfigurationSource())&#10;            .and()&#10;            .csrf().disable()&#10;            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;            .and()&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .requestMatchers(&quot;/api/v1/auth/**&quot;, &quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/v1/admin/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(&quot;/api/v1/products&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/v1/products/**&quot;).authenticated()&#10;                .anyRequest().authenticated()&#10;            )&#10;            .addFilterBefore(jwtAuthorizationFilter, UsernamePasswordAuthenticationFilter.class)&#10;            .addFilter(new JwtAuthenticationFilter(authenticationManager(&#10;                http.getSharedObject(AuthenticationConfiguration.class))));&#10;&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {&#10;        return config.getAuthenticationManager();&#10;    }&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(List.of(&quot;*&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));&#10;        configuration.setAllowedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;, &quot;X-Requested-With&quot;));&#10;        &#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        &#10;        return source;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/controller/OrderController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/controller/OrderController.java" />
              <option name="updatedContent" value="package com.example.ecommerce.controller;&#10;&#10;import com.example.ecommerce.dto.OrderRequest;&#10;import com.example.ecommerce.dto.OrderResponse;&#10;import com.example.ecommerce.model.Order;&#10;import com.example.ecommerce.model.OrderStatus;&#10;import com.example.ecommerce.service.OrderService;&#10;import io.swagger.v3.oas.annotations.Operation;&#10;import io.swagger.v3.oas.annotations.responses.ApiResponse;&#10;import io.swagger.v3.oas.annotations.security.SecurityRequirement;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.net.URI;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/orders&quot;)&#10;@RequiredArgsConstructor&#10;public class OrderController {&#10;    private final OrderService orderService;&#10;&#10;    @PostMapping&#10;    @Operation(summary = &quot;Create a new order&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('USER')&quot;)&#10;    public ResponseEntity&lt;OrderResponse&gt; createOrder(@Valid @RequestBody OrderRequest orderRequest) {&#10;        Order order = orderService.createOrder(orderRequest);&#10;        return ResponseEntity&#10;            .created(URI.create(&quot;/api/v1/orders/&quot; + order.getId()))&#10;            .body(OrderResponse.fromOrder(order));&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    @Operation(summary = &quot;Get order by ID&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('USER')&quot;)&#10;    public ResponseEntity&lt;OrderResponse&gt; getOrder(@PathVariable Long id) {&#10;        return orderService.getOrder(id)&#10;            .map(OrderResponse::fromOrder)&#10;            .map(ResponseEntity::ok)&#10;            .orElse(ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}/status&quot;)&#10;    @Operation(summary = &quot;Update order status&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;OrderResponse&gt; updateOrderStatus(&#10;            @PathVariable Long id,&#10;            @RequestParam OrderStatus status) {&#10;        Order updatedOrder = orderService.updateOrderStatus(id, status);&#10;        return ResponseEntity.ok(OrderResponse.fromOrder(updatedOrder));&#10;    }&#10;&#10;    @PostMapping(&quot;/{id}/cancel&quot;)&#10;    @Operation(summary = &quot;Cancel an order&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('USER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; cancelOrder(@PathVariable Long id) {&#10;        boolean cancelled = orderService.cancelOrder(id);&#10;        return cancelled ? ResponseEntity.ok().build() : ResponseEntity.badRequest().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/user/{userId}&quot;)&#10;    @Operation(summary = &quot;Get user's orders&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('USER') and @userSecurity.isOwner(#userId)&quot;)&#10;    public ResponseEntity&lt;Page&lt;OrderResponse&gt;&gt; getUserOrders(&#10;            @PathVariable Long userId,&#10;            Pageable pageable) {&#10;        Page&lt;Order&gt; orders = orderService.getUserOrders(userId, pageable);&#10;        return ResponseEntity.ok(orders.map(OrderResponse::fromOrder));&#10;    }&#10;&#10;    @PostMapping(&quot;/{id}/delivery/confirm&quot;)&#10;    @Operation(summary = &quot;Confirm order delivery&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('USER') and @orderSecurity.canConfirmDelivery(#id)&quot;)&#10;    public ResponseEntity&lt;OrderResponse&gt; confirmDelivery(@PathVariable Long id) {&#10;        Order order = orderService.confirmDelivery(id);&#10;        return ResponseEntity.ok(OrderResponse.fromOrder(order));&#10;    }&#10;&#10;    @PostMapping(&quot;/{id}/return&quot;)&#10;    @Operation(summary = &quot;Initiate order return&quot;, security = @SecurityRequirement(name = &quot;bearerAuth&quot;))&#10;    @PreAuthorize(&quot;hasRole('USER') and @orderSecurity.canInitiateReturn(#id)&quot;)&#10;    public ResponseEntity&lt;OrderResponse&gt; initiateReturn(&#10;            @PathVariable Long id,&#10;            @RequestParam String reason) {&#10;        Order order = orderService.initiateReturn(id, reason);&#10;        return ResponseEntity.ok(OrderResponse.fromOrder(order));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/model/Order.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/model/Order.java" />
              <option name="updatedContent" value="package com.example.ecommerce.model;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.Data;&#10;import org.hibernate.annotations.CreationTimestamp;&#10;import org.hibernate.annotations.UpdateTimestamp;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;@Data&#10;@Entity&#10;@Table(name = &quot;orders&quot;)&#10;public class Order {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(unique = true, nullable = false)&#10;    private String orderNumber = UUID.randomUUID().toString();&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;user_id&quot;, nullable = false)&#10;    private User user;&#10;&#10;    @OneToMany(mappedBy = &quot;order&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private List&lt;OrderItem&gt; items = new ArrayList&lt;&gt;();&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private OrderStatus status = OrderStatus.CREATED;&#10;&#10;    @OneToOne(cascade = CascadeType.ALL)&#10;    @JoinColumn(name = &quot;payment_id&quot;)&#10;    private Payment payment;&#10;&#10;    @OneToOne(cascade = CascadeType.ALL)&#10;    @JoinColumn(name = &quot;shipping_address_id&quot;)&#10;    private Address shippingAddress;&#10;&#10;    @Column(nullable = false)&#10;    private BigDecimal totalAmount = BigDecimal.ZERO;&#10;&#10;    @Column(name = &quot;shipping_cost&quot;)&#10;    private BigDecimal shippingCost = BigDecimal.ZERO;&#10;&#10;    @Column(name = &quot;tax_amount&quot;)&#10;    private BigDecimal taxAmount = BigDecimal.ZERO;&#10;&#10;    @Version&#10;    private Long version;&#10;&#10;    @CreationTimestamp&#10;    @Column(name = &quot;created_at&quot;, updatable = false)&#10;    private LocalDateTime createdAt;&#10;&#10;    @UpdateTimestamp&#10;    @Column(name = &quot;updated_at&quot;)&#10;    private LocalDateTime updatedAt;&#10;&#10;    @Column(name = &quot;completed_at&quot;)&#10;    private LocalDateTime completedAt;&#10;&#10;    public void addItem(OrderItem item) {&#10;        items.add(item);&#10;        item.setOrder(this);&#10;        recalculateTotal();&#10;    }&#10;&#10;    public void removeItem(OrderItem item) {&#10;        items.remove(item);&#10;        item.setOrder(null);&#10;        recalculateTotal();&#10;    }&#10;&#10;    public void recalculateTotal() {&#10;        this.totalAmount = items.stream()&#10;                .map(OrderItem::getSubtotal)&#10;                .reduce(BigDecimal.ZERO, BigDecimal::add)&#10;                .add(shippingCost)&#10;                .add(taxAmount);&#10;    }&#10;&#10;    public boolean canCancel() {&#10;        return status == OrderStatus.CREATED || &#10;               status == OrderStatus.CONFIRMED || &#10;               status == OrderStatus.PAYMENT_PENDING;&#10;    }&#10;&#10;    public void updateStatus(OrderStatus newStatus) {&#10;        validateStatusTransition(newStatus);&#10;        this.status = newStatus;&#10;        if (newStatus == OrderStatus.COMPLETED) {&#10;            this.completedAt = LocalDateTime.now();&#10;        }&#10;    }&#10;&#10;    private void validateStatusTransition(OrderStatus newStatus) {&#10;        if (!isValidStatusTransition(newStatus)) {&#10;            throw new IllegalStateException(&#10;                &quot;Invalid order status transition from &quot; + this.status + &quot; to &quot; + newStatus);&#10;        }&#10;    }&#10;&#10;    private boolean isValidStatusTransition(OrderStatus newStatus) {&#10;        switch (this.status) {&#10;            case CREATED:&#10;                return newStatus == OrderStatus.CONFIRMED || &#10;                       newStatus == OrderStatus.CANCELLED;&#10;            case CONFIRMED:&#10;                return newStatus == OrderStatus.PAYMENT_PENDING || &#10;                       newStatus == OrderStatus.CANCELLED;&#10;            case PAYMENT_PENDING:&#10;                return newStatus == OrderStatus.PAID || &#10;                       newStatus == OrderStatus.PAYMENT_FAILED || &#10;                       newStatus == OrderStatus.CANCELLED;&#10;            case PAID:&#10;                return newStatus == OrderStatus.PROCESSING || &#10;                       newStatus == OrderStatus.REFUNDED;&#10;            case PROCESSING:&#10;                return newStatus == OrderStatus.SHIPPED || &#10;                       newStatus == OrderStatus.CANCELLED;&#10;            case SHIPPED:&#10;                return newStatus == OrderStatus.DELIVERED || &#10;                       newStatus == OrderStatus.RETURNED;&#10;            case DELIVERED:&#10;                return newStatus == OrderStatus.COMPLETED || &#10;                       newStatus == OrderStatus.RETURNED;&#10;            default:&#10;                return false;&#10;        }&#10;    }&#10;}&#10;&#10;enum OrderStatus {&#10;    CREATED,&#10;    CONFIRMED,&#10;    PAYMENT_PENDING,&#10;    PAYMENT_FAILED,&#10;    PAID,&#10;    PROCESSING,&#10;    SHIPPED,&#10;    DELIVERED,&#10;    COMPLETED,&#10;    CANCELLED,&#10;    REFUNDED,&#10;    RETURNED&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/model/Product.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/model/Product.java" />
              <option name="updatedContent" value="package com.example.ecommerce.model;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.validation.constraints.DecimalMin;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.Data;&#10;import org.hibernate.annotations.Cache;&#10;import org.hibernate.annotations.CacheConcurrencyStrategy;&#10;import org.hibernate.annotations.CreationTimestamp;&#10;import org.hibernate.annotations.UpdateTimestamp;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDateTime;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Entity&#10;@Table(name = &quot;products&quot;)&#10;@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)&#10;public class Product {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @NotBlank&#10;    private String name;&#10;&#10;    @NotBlank&#10;    @Column(length = 2000)&#10;    private String description;&#10;&#10;    @NotNull&#10;    @DecimalMin(value = &quot;0.0&quot;)&#10;    private BigDecimal price;&#10;&#10;    @NotNull&#10;    @Column(name = &quot;stock_quantity&quot;)&#10;    private Integer stockQuantity;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;category_id&quot;)&#10;    private Category category;&#10;&#10;    @OneToMany(mappedBy = &quot;product&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private Set&lt;ProductImage&gt; images = new HashSet&lt;&gt;();&#10;&#10;    @OneToMany(mappedBy = &quot;product&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private Set&lt;ProductReview&gt; reviews = new HashSet&lt;&gt;();&#10;&#10;    @ManyToMany&#10;    @JoinTable(name = &quot;product_tags&quot;,&#10;            joinColumns = @JoinColumn(name = &quot;product_id&quot;),&#10;            inverseJoinColumns = @JoinColumn(name = &quot;tag_id&quot;))&#10;    private Set&lt;Tag&gt; tags = new HashSet&lt;&gt;();&#10;&#10;    @Version&#10;    private Long version;&#10;&#10;    @Column(name = &quot;average_rating&quot;)&#10;    private Double averageRating;&#10;&#10;    @Column(name = &quot;total_reviews&quot;)&#10;    private Integer totalReviews = 0;&#10;&#10;    @Column(name = &quot;is_featured&quot;)&#10;    private boolean featured;&#10;&#10;    @Column(name = &quot;is_active&quot;)&#10;    private boolean active = true;&#10;&#10;    @CreationTimestamp&#10;    @Column(name = &quot;created_at&quot;, updatable = false)&#10;    private LocalDateTime createdAt;&#10;&#10;    @UpdateTimestamp&#10;    @Column(name = &quot;updated_at&quot;)&#10;    private LocalDateTime updatedAt;&#10;&#10;    // Business logic methods&#10;    public void updateStock(int quantity) {&#10;        if (this.stockQuantity + quantity &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Insufficient stock&quot;);&#10;        }&#10;        this.stockQuantity += quantity;&#10;    }&#10;&#10;    public void addReview(ProductReview review) {&#10;        reviews.add(review);&#10;        updateAverageRating();&#10;    }&#10;&#10;    private void updateAverageRating() {&#10;        this.averageRating = reviews.stream()&#10;                .mapToDouble(ProductReview::getRating)&#10;                .average()&#10;                .orElse(0.0);&#10;        this.totalReviews = reviews.size();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/model/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/model/User.java" />
              <option name="updatedContent" value="package com.example.ecommerce.model;&#10;&#10;import jakarta.persistence.*;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.hibernate.annotations.CreationTimestamp;&#10;import org.hibernate.annotations.UpdateTimestamp;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;@Data&#10;@NoArgsConstructor&#10;@Entity&#10;@Table(name = &quot;users&quot;)&#10;public class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @NotBlank&#10;    @Column(unique = true)&#10;    private String username;&#10;&#10;    @NotBlank&#10;    @Email&#10;    @Column(unique = true)&#10;    private String email;&#10;&#10;    @NotBlank&#10;    private String password;&#10;&#10;    @ManyToMany(fetch = FetchType.EAGER)&#10;    @JoinTable(name = &quot;user_roles&quot;,&#10;            joinColumns = @JoinColumn(name = &quot;user_id&quot;),&#10;            inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;))&#10;    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();&#10;&#10;    @OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL)&#10;    private Set&lt;Address&gt; addresses = new HashSet&lt;&gt;();&#10;&#10;    @OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL)&#10;    private Cart cart;&#10;&#10;    private boolean enabled = false;&#10;&#10;    @Column(name = &quot;email_verified&quot;)&#10;    private boolean emailVerified = false;&#10;&#10;    @Column(name = &quot;account_non_locked&quot;)&#10;    private boolean accountNonLocked = true;&#10;&#10;    @Column(name = &quot;failed_attempt&quot;)&#10;    private int failedAttempt;&#10;&#10;    @Column(name = &quot;lock_time&quot;)&#10;    private LocalDateTime lockTime;&#10;&#10;    @CreationTimestamp&#10;    @Column(name = &quot;created_at&quot;, updatable = false)&#10;    private LocalDateTime createdAt;&#10;&#10;    @UpdateTimestamp&#10;    @Column(name = &quot;updated_at&quot;)&#10;    private LocalDateTime updatedAt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/OrderService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/OrderService.java" />
              <option name="updatedContent" value="package com.example.ecommerce.service;&#10;&#10;import com.example.ecommerce.dto.OrderRequest;&#10;import com.example.ecommerce.model.Order;&#10;import com.example.ecommerce.model.OrderStatus;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface OrderService {&#10;    Order createOrder(OrderRequest orderRequest);&#10;    Optional&lt;Order&gt; getOrder(Long id);&#10;    Order updateOrderStatus(Long id, OrderStatus status);&#10;    boolean cancelOrder(Long id);&#10;    Page&lt;Order&gt; getUserOrders(Long userId, Pageable pageable);&#10;    Order processPayment(Long orderId, String paymentMethod);&#10;    Order confirmDelivery(Long orderId);&#10;    Order initiateReturn(Long orderId, String reason);&#10;    List&lt;Order&gt; findOrdersByStatus(OrderStatus status);&#10;    boolean validateOrder(Long orderId);&#10;    void sendOrderConfirmation(Long orderId);&#10;    Order applyDiscount(Long orderId, String couponCode);&#10;    Order recalculateOrderTotal(Long orderId);&#10;    void scheduleDelivery(Long orderId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/ProductService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/ProductService.java" />
              <option name="updatedContent" value="package com.example.ecommerce.service;&#10;&#10;import com.example.ecommerce.model.Product;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface ProductService {&#10;    Product createProduct(Product product);&#10;    Product updateProduct(Long id, Product product);&#10;    Optional&lt;Product&gt; getProduct(Long id);&#10;    Page&lt;Product&gt; searchProducts(String query, Pageable pageable);&#10;    List&lt;Product&gt; getFeaturedProducts();&#10;    void deleteProduct(Long id);&#10;    boolean updateStock(Long productId, int quantity);&#10;    List&lt;Product&gt; getProductsByCategory(Long categoryId);&#10;    List&lt;Product&gt; getProductsByPriceRange(BigDecimal min, BigDecimal max);&#10;    void updateProductRating(Long productId);&#10;    boolean reserveStock(Long productId, int quantity);&#10;    void releaseStock(Long productId, int quantity);&#10;    List&lt;Product&gt; getRelatedProducts(Long productId);&#10;    Page&lt;Product&gt; getProductsByTags(List&lt;String&gt; tags, Pageable pageable);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/impl/OrderServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/impl/OrderServiceImpl.java" />
              <option name="updatedContent" value="package com.example.ecommerce.service.impl;&#10;&#10;import com.example.ecommerce.dto.OrderRequest;&#10;import com.example.ecommerce.event.OrderEvent;&#10;import com.example.ecommerce.exception.*;&#10;import com.example.ecommerce.model.Order;&#10;import com.example.ecommerce.model.OrderStatus;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.repository.OrderRepository;&#10;import com.example.ecommerce.service.OrderService;&#10;import com.example.ecommerce.service.ProductService;&#10;import com.example.ecommerce.service.NotificationService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.context.ApplicationEventPublisher;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.retry.annotation.Retryable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Isolation;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class OrderServiceImpl implements OrderService {&#10;    private final OrderRepository orderRepository;&#10;    private final ProductService productService;&#10;    private final NotificationService notificationService;&#10;    private final ApplicationEventPublisher eventPublisher;&#10;&#10;    @Override&#10;    @Transactional(isolation = Isolation.REPEATABLE_READ)&#10;    public Order createOrder(OrderRequest orderRequest) {&#10;        log.info(&quot;Creating new order for user: {}&quot;, orderRequest.getUserId());&#10;        &#10;        // Validate and reserve stock for all items&#10;        validateAndReserveStock(orderRequest);&#10;        &#10;        try {&#10;            Order order = buildOrderFromRequest(orderRequest);&#10;            order = orderRepository.save(order);&#10;            &#10;            // Async notification&#10;            CompletableFuture.runAsync(() -&gt; notificationService.sendOrderCreationNotification(order));&#10;            &#10;            // Publish event&#10;            eventPublisher.publishEvent(new OrderEvent(this, order.getId(), &quot;ORDER_CREATED&quot;));&#10;            &#10;            return order;&#10;        } catch (Exception e) {&#10;            // Release reserved stock in case of failure&#10;            rollbackStockReservations(orderRequest);&#10;            throw new OrderCreationException(&quot;Failed to create order&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    @Retryable(maxAttempts = 3)&#10;    public Order updateOrderStatus(Long id, OrderStatus newStatus) {&#10;        Order order = orderRepository.findById(id)&#10;            .orElseThrow(() -&gt; new OrderNotFoundException(&quot;Order not found: &quot; + id));&#10;            &#10;        try {&#10;            order.updateStatus(newStatus);&#10;            order = orderRepository.save(order);&#10;            &#10;            // Handle status-specific actions&#10;            handleStatusSpecificActions(order, newStatus);&#10;            &#10;            // Publish event&#10;            eventPublisher.publishEvent(new OrderEvent(this, order.getId(), &quot;STATUS_UPDATED_&quot; + newStatus));&#10;            &#10;            return order;&#10;        } catch (IllegalStateException e) {&#10;            throw new InvalidStatusTransitionException(&quot;Invalid status transition&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public Optional&lt;Order&gt; getOrder(Long id) {&#10;        return orderRepository.findById(id);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public boolean cancelOrder(Long id) {&#10;        Order order = orderRepository.findById(id)&#10;            .orElseThrow(() -&gt; new OrderNotFoundException(&quot;Order not found: &quot; + id));&#10;&#10;        if (!order.canCancel()) {&#10;            throw new OrderCancellationException(&quot;Order cannot be cancelled in current status: &quot; + order.getStatus());&#10;        }&#10;&#10;        try {&#10;            // Release reserved stock&#10;            order.getItems().forEach(item -&gt; &#10;                productService.releaseStock(item.getProduct().getId(), item.getQuantity()));&#10;&#10;            order.updateStatus(OrderStatus.CANCELLED);&#10;            orderRepository.save(order);&#10;&#10;            // Async notification&#10;            CompletableFuture.runAsync(() -&gt; notificationService.sendOrderCancellationNotification(order));&#10;&#10;            // Publish event&#10;            eventPublisher.publishEvent(new OrderEvent(this, order.getId(), &quot;ORDER_CANCELLED&quot;));&#10;&#10;            return true;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to cancel order: {}&quot;, id, e);&#10;            throw new OrderCancellationException(&quot;Failed to cancel order&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void validateAndReserveStock(OrderRequest orderRequest) {&#10;        orderRequest.getItems().forEach(item -&gt; {&#10;            if (!productService.reserveStock(item.getProductId(), item.getQuantity())) {&#10;                throw new InsufficientStockException(&#10;                    &quot;Insufficient stock for product: &quot; + item.getProductId());&#10;            }&#10;        });&#10;    }&#10;&#10;    private void rollbackStockReservations(OrderRequest orderRequest) {&#10;        orderRequest.getItems().forEach(item -&gt; {&#10;            try {&#10;                productService.releaseStock(item.getProductId(), item.getQuantity());&#10;            } catch (Exception e) {&#10;                log.error(&quot;Failed to release stock for product: {}&quot;, item.getProductId(), e);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void handleStatusSpecificActions(Order order, OrderStatus newStatus) {&#10;        switch (newStatus) {&#10;            case PAID:&#10;                processSuccessfulPayment(order);&#10;                break;&#10;            case SHIPPED:&#10;                initiateShipment(order);&#10;                break;&#10;            case DELIVERED:&#10;                completeDelivery(order);&#10;                break;&#10;            case RETURNED:&#10;                processReturn(order);&#10;                break;&#10;            default:&#10;                // No specific action needed&#10;        }&#10;    }&#10;&#10;    private void processSuccessfulPayment(Order order) {&#10;        CompletableFuture.runAsync(() -&gt; {&#10;            notificationService.sendPaymentConfirmation(order);&#10;            // Additional payment processing logic&#10;        });&#10;    }&#10;&#10;    private void initiateShipment(Order order) {&#10;        CompletableFuture.runAsync(() -&gt; {&#10;            notificationService.sendShipmentNotification(order);&#10;            // Additional shipment processing logic&#10;        });&#10;    }&#10;&#10;    private void completeDelivery(Order order) {&#10;        order.setCompletedAt(LocalDateTime.now());&#10;        CompletableFuture.runAsync(() -&gt; {&#10;            notificationService.sendDeliveryConfirmation(order);&#10;            // Additional delivery completion logic&#10;        });&#10;    }&#10;&#10;    private void processReturn(Order order) {&#10;        CompletableFuture.runAsync(() -&gt; {&#10;            notificationService.sendReturnConfirmation(order);&#10;            // Process refund and return logic&#10;        });&#10;    }&#10;&#10;    // Additional interface method implementations...&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/impl/ProductServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/main/java/com/example/ecommerce/service/impl/ProductServiceImpl.java" />
              <option name="updatedContent" value="package com.example.ecommerce.service.impl;&#10;&#10;import com.example.ecommerce.event.ProductStockEvent;&#10;import com.example.ecommerce.exception.ProductNotFoundException;&#10;import com.example.ecommerce.exception.StockUpdateException;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.repository.ProductRepository;&#10;import com.example.ecommerce.service.ProductService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.cache.annotation.CacheEvict;&#10;import org.springframework.cache.annotation.Cacheable;&#10;import org.springframework.context.ApplicationEventPublisher;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.retry.annotation.Retryable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.concurrent.locks.Lock;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class ProductServiceImpl implements ProductService {&#10;    private final ProductRepository productRepository;&#10;    private final ApplicationEventPublisher eventPublisher;&#10;    private final Lock stockUpdateLock = new ReentrantLock();&#10;&#10;    @Override&#10;    @Transactional&#10;    public Product createProduct(Product product) {&#10;        validateProduct(product);&#10;        Product savedProduct = productRepository.save(product);&#10;        eventPublisher.publishEvent(new ProductStockEvent(this, savedProduct.getId(), &quot;CREATED&quot;, savedProduct.getStockQuantity()));&#10;        return savedProduct;&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    @CacheEvict(value = &quot;products&quot;, key = &quot;#id&quot;)&#10;    public Product updateProduct(Long id, Product product) {&#10;        Product existingProduct = productRepository.findById(id)&#10;                .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product not found with id: &quot; + id));&#10;        &#10;        updateProductFields(existingProduct, product);&#10;        return productRepository.save(existingProduct);&#10;    }&#10;&#10;    @Override&#10;    @Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)&#10;    public Optional&lt;Product&gt; getProduct(Long id) {&#10;        return productRepository.findById(id);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    @Retryable(maxAttempts = 3)&#10;    public boolean updateStock(Long productId, int quantity) {&#10;        stockUpdateLock.lock();&#10;        try {&#10;            Product product = productRepository.findById(productId)&#10;                    .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product not found with id: &quot; + productId));&#10;&#10;            if (quantity &lt; 0 &amp;&amp; Math.abs(quantity) &gt; product.getStockQuantity()) {&#10;                throw new StockUpdateException(&quot;Insufficient stock for product: &quot; + productId);&#10;            }&#10;&#10;            product.updateStock(quantity);&#10;            productRepository.save(product);&#10;            eventPublisher.publishEvent(new ProductStockEvent(this, productId, &quot;UPDATED&quot;, product.getStockQuantity()));&#10;            return true;&#10;        } finally {&#10;            stockUpdateLock.unlock();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public Page&lt;Product&gt; searchProducts(String query, Pageable pageable) {&#10;        return productRepository.findByNameContainingOrDescriptionContainingAllIgnoreCase(query, query, pageable);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public boolean reserveStock(Long productId, int quantity) {&#10;        stockUpdateLock.lock();&#10;        try {&#10;            Product product = productRepository.findById(productId)&#10;                    .orElseThrow(() -&gt; new ProductNotFoundException(&quot;Product not found with id: &quot; + productId));&#10;&#10;            if (product.getStockQuantity() &lt; quantity) {&#10;                return false;&#10;            }&#10;&#10;            product.updateStock(-quantity);&#10;            productRepository.save(product);&#10;            eventPublisher.publishEvent(new ProductStockEvent(this, productId, &quot;RESERVED&quot;, product.getStockQuantity()));&#10;            return true;&#10;        } finally {&#10;            stockUpdateLock.unlock();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void releaseStock(Long productId, int quantity) {&#10;        updateStock(productId, quantity);&#10;        eventPublisher.publishEvent(new ProductStockEvent(this, productId, &quot;RELEASED&quot;, quantity));&#10;    }&#10;&#10;    private void validateProduct(Product product) {&#10;        if (product.getPrice().compareTo(BigDecimal.ZERO) &lt;= 0) {&#10;            throw new IllegalArgumentException(&quot;Product price must be greater than zero&quot;);&#10;        }&#10;        if (product.getStockQuantity() &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;Product stock quantity cannot be negative&quot;);&#10;        }&#10;    }&#10;&#10;    private void updateProductFields(Product existing, Product updated) {&#10;        existing.setName(updated.getName());&#10;        existing.setDescription(updated.getDescription());&#10;        existing.setPrice(updated.getPrice());&#10;        existing.setCategory(updated.getCategory());&#10;        existing.setFeatured(updated.isFeatured());&#10;        existing.setActive(updated.isActive());&#10;    }&#10;&#10;    // Other interface method implementations...&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/api/ProductApiTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/api/ProductApiTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.api;&#10;&#10;import com.example.ecommerce.dto.ProductRequest;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.test.BaseIntegrationTest;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Tag;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.params.ParameterizedTest;&#10;import org.junit.jupiter.params.provider.CsvSource;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.security.test.context.support.WithMockUser;&#10;import org.springframework.test.web.servlet.ResultActions;&#10;&#10;import java.math.BigDecimal;&#10;&#10;import static org.hamcrest.Matchers.*;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@Tag(&quot;api&quot;)&#10;class ProductApiTest extends BaseIntegrationTest {&#10;&#10;    @Test&#10;    @DisplayName(&quot;GET /api/v1/products - Should return paginated products&quot;)&#10;    void getProducts_ShouldReturnPaginatedResults() throws Exception {&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/v1/products&quot;)&#10;                .param(&quot;page&quot;, &quot;0&quot;)&#10;                .param(&quot;size&quot;, &quot;10&quot;)&#10;                .param(&quot;sort&quot;, &quot;name,asc&quot;))&#10;                .andDo(print())&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.content&quot;, isA(Array.class)))&#10;                .andExpect(jsonPath(&quot;$.totalElements&quot;, greaterThanOrEqualTo(0)))&#10;                .andExpect(jsonPath(&quot;$.pageable.pageSize&quot;, is(10)));&#10;    }&#10;&#10;    @ParameterizedTest&#10;    @CsvSource({&#10;        &quot;name,asc,$.content[0].name&quot;,&#10;        &quot;price,desc,$.content[0].price&quot;,&#10;        &quot;createdAt,desc,$.content[0].createdAt&quot;&#10;    })&#10;    @DisplayName(&quot;GET /api/v1/products - Should support different sort options&quot;)&#10;    void getProducts_ShouldSupportSorting(String sortField, String sortDir, String jsonPath) throws Exception {&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/v1/products&quot;)&#10;                .param(&quot;sort&quot;, String.format(&quot;%s,%s&quot;, sortField, sortDir)))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(jsonPath).exists());&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser(roles = &quot;ADMIN&quot;)&#10;    @DisplayName(&quot;POST /api/v1/products - Should create new product&quot;)&#10;    void createProduct_WithValidData_ShouldSucceed() throws Exception {&#10;        // Arrange&#10;        ProductRequest request = new ProductRequest();&#10;        request.setName(&quot;Test Product&quot;);&#10;        request.setDescription(&quot;Test Description&quot;);&#10;        request.setPrice(new BigDecimal(&quot;99.99&quot;));&#10;        request.setStockQuantity(100);&#10;&#10;        // Act&#10;        ResultActions result = mockMvc.perform(post(&quot;/api/v1/products&quot;)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .content(asJsonString(request)));&#10;&#10;        // Assert&#10;        result.andDo(print())&#10;                .andExpect(status().isCreated())&#10;                .andExpect(header().exists(&quot;Location&quot;))&#10;                .andExpect(jsonPath(&quot;$.id&quot;).exists())&#10;                .andExpect(jsonPath(&quot;$.name&quot;, is(request.getName())))&#10;                .andExpect(jsonPath(&quot;$.price&quot;, is(99.99)));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;GET /api/v1/products/search - Should return filtered results&quot;)&#10;    void searchProducts_ShouldReturnFilteredResults() throws Exception {&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/v1/products/search&quot;)&#10;                .param(&quot;query&quot;, &quot;test&quot;)&#10;                .param(&quot;minPrice&quot;, &quot;10.00&quot;)&#10;                .param(&quot;maxPrice&quot;, &quot;100.00&quot;)&#10;                .param(&quot;category&quot;, &quot;electronics&quot;))&#10;                .andDo(print())&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.content[*]&quot;).exists())&#10;                .andExpect(jsonPath(&quot;$.content[*].price&quot;, everyItem(greaterThanOrEqualTo(10.00))))&#10;                .andExpect(jsonPath(&quot;$.content[*].price&quot;, everyItem(lessThanOrEqualTo(100.00))));&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser(roles = &quot;ADMIN&quot;)&#10;    @DisplayName(&quot;PUT /api/v1/products/{id} - Should update existing product&quot;)&#10;    void updateProduct_WithValidData_ShouldSucceed() throws Exception {&#10;        // Arrange&#10;        Long productId = 1L;&#10;        ProductRequest request = new ProductRequest();&#10;        request.setName(&quot;Updated Product&quot;);&#10;        request.setPrice(new BigDecimal(&quot;199.99&quot;));&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(put(&quot;/api/v1/products/{id}&quot;, productId)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .content(asJsonString(request)))&#10;                .andDo(print())&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.name&quot;, is(request.getName())))&#10;                .andExpect(jsonPath(&quot;$.price&quot;, is(199.99)));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;GET /api/v1/products/{id} - Should return 404 for non-existent product&quot;)&#10;    void getProduct_WithNonExistentId_ShouldReturn404() throws Exception {&#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/v1/products/{id}&quot;, 999999))&#10;                .andDo(print())&#10;                .andExpect(status().isNotFound());&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser(roles = &quot;ADMIN&quot;)&#10;    @DisplayName(&quot;POST /api/v1/products - Should validate request data&quot;)&#10;    void createProduct_WithInvalidData_ShouldReturn400() throws Exception {&#10;        // Arrange&#10;        ProductRequest request = new ProductRequest();&#10;        // Missing required fields&#10;&#10;        // Act &amp; Assert&#10;        mockMvc.perform(post(&quot;/api/v1/products&quot;)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .content(asJsonString(request)))&#10;                .andDo(print())&#10;                .andExpect(status().isBadRequest())&#10;                .andExpect(jsonPath(&quot;$.errors&quot;).exists())&#10;                .andExpect(jsonPath(&quot;$.errors[*].field&quot;).value(hasItems(&quot;name&quot;, &quot;price&quot;)));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;GET /api/v1/products - Should handle server errors gracefully&quot;)&#10;    void getProducts_WithServerError_ShouldReturn500() throws Exception {&#10;        // This test requires setting up a condition that would trigger a server error&#10;        // Usually done through mock configuration or test-specific configuration&#10;        &#10;        // Act &amp; Assert&#10;        mockMvc.perform(get(&quot;/api/v1/products&quot;)&#10;                .header(&quot;X-Trigger-Error&quot;, &quot;true&quot;)) // Custom header to trigger error in test&#10;                .andDo(print())&#10;                .andExpect(status().isInternalServerError())&#10;                .andExpect(jsonPath(&quot;$.message&quot;).exists())&#10;                .andExpect(jsonPath(&quot;$.timestamp&quot;).exists());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/config/TestContainersConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/config/TestContainersConfig.java" />
              <option name="updatedContent" value="package com.example.ecommerce.config;&#10;&#10;import org.springframework.boot.test.context.TestConfiguration;&#10;import org.springframework.context.annotation.Bean;&#10;import org.testcontainers.containers.PostgreSQLContainer;&#10;import org.testcontainers.containers.RabbitMQContainer;&#10;import org.testcontainers.containers.RedisContainer;&#10;import org.testcontainers.utility.DockerImageName;&#10;&#10;@TestConfiguration&#10;public class TestContainersConfig {&#10;&#10;    @Bean&#10;    public PostgreSQLContainer&lt;?&gt; postgreSQLContainer() {&#10;        PostgreSQLContainer&lt;?&gt; container = new PostgreSQLContainer&lt;&gt;(DockerImageName.parse(&quot;postgres:14-alpine&quot;))&#10;                .withDatabaseName(&quot;testdb&quot;)&#10;                .withUsername(&quot;test&quot;)&#10;                .withPassword(&quot;test&quot;);&#10;        container.start();&#10;        System.setProperty(&quot;spring.datasource.url&quot;, container.getJdbcUrl());&#10;        System.setProperty(&quot;spring.datasource.username&quot;, container.getUsername());&#10;        System.setProperty(&quot;spring.datasource.password&quot;, container.getPassword());&#10;        return container;&#10;    }&#10;&#10;    @Bean&#10;    public RedisContainer redisContainer() {&#10;        RedisContainer container = new RedisContainer(DockerImageName.parse(&quot;redis:6-alpine&quot;));&#10;        container.start();&#10;        System.setProperty(&quot;spring.redis.host&quot;, container.getHost());&#10;        System.setProperty(&quot;spring.redis.port&quot;, container.getFirstMappedPort().toString());&#10;        return container;&#10;    }&#10;&#10;    @Bean&#10;    public RabbitMQContainer rabbitMQContainer() {&#10;        RabbitMQContainer container = new RabbitMQContainer(DockerImageName.parse(&quot;rabbitmq:3-management-alpine&quot;))&#10;                .withQueue(&quot;orders&quot;)&#10;                .withQueue(&quot;notifications&quot;);&#10;        container.start();&#10;        System.setProperty(&quot;spring.rabbitmq.host&quot;, container.getHost());&#10;        System.setProperty(&quot;spring.rabbitmq.port&quot;, container.getAmqpPort().toString());&#10;        return container;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/controller/OrderControllerIntegrationTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/controller/OrderControllerIntegrationTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.controller;&#10;&#10;import com.example.ecommerce.dto.OrderRequest;&#10;import com.example.ecommerce.model.Order;&#10;import com.example.ecommerce.model.OrderStatus;&#10;import com.example.ecommerce.model.User;&#10;import com.example.ecommerce.repository.OrderRepository;&#10;import com.example.ecommerce.repository.UserRepository;&#10;import com.example.ecommerce.security.JwtTokenProvider;&#10;import com.example.ecommerce.test.BaseIntegrationTest;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.test.web.servlet.ResultActions;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import static org.hamcrest.CoreMatchers.is;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;class OrderControllerIntegrationTest extends BaseIntegrationTest {&#10;&#10;    @Autowired&#10;    private OrderRepository orderRepository;&#10;&#10;    @Autowired&#10;    private UserRepository userRepository;&#10;&#10;    @Autowired&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    @Autowired&#10;    private JwtTokenProvider jwtTokenProvider;&#10;&#10;    private User testUser;&#10;    private String userToken;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Clean up data&#10;        orderRepository.deleteAll();&#10;        userRepository.deleteAll();&#10;&#10;        // Create test user&#10;        testUser = createTestUser();&#10;        userToken = jwtTokenProvider.generateToken(testUser.getUsername());&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Create Order Tests&quot;)&#10;    class CreateOrderTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should successfully create order for authenticated user&quot;)&#10;        void createOrder_WithValidRequest_ShouldSucceed() throws Exception {&#10;            // Arrange&#10;            OrderRequest request = createSampleOrderRequest();&#10;&#10;            // Act&#10;            ResultActions result = mockMvc.perform(post(&quot;/api/v1/orders&quot;)&#10;                    .header(&quot;Authorization&quot;, &quot;Bearer &quot; + userToken)&#10;                    .contentType(MediaType.APPLICATION_JSON)&#10;                    .content(asJsonString(request)));&#10;&#10;            // Assert&#10;            result.andExpect(status().isCreated())&#10;                    .andExpect(jsonPath(&quot;$.status&quot;, is(OrderStatus.CREATED.name())))&#10;                    .andExpect(jsonPath(&quot;$.userId&quot;, is(testUser.getId().intValue())));&#10;&#10;            // Verify database state&#10;            List&lt;Order&gt; orders = orderRepository.findByUserId(testUser.getId());&#10;            assertEquals(1, orders.size());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should fail to create order without authentication&quot;)&#10;        void createOrder_WithoutAuth_ShouldFail() throws Exception {&#10;            // Arrange&#10;            OrderRequest request = createSampleOrderRequest();&#10;&#10;            // Act &amp; Assert&#10;            mockMvc.perform(post(&quot;/api/v1/orders&quot;)&#10;                    .contentType(MediaType.APPLICATION_JSON)&#10;                    .content(asJsonString(request)))&#10;                    .andExpect(status().isUnauthorized());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should fail to create order with invalid data&quot;)&#10;        void createOrder_WithInvalidData_ShouldFail() throws Exception {&#10;            // Arrange&#10;            OrderRequest request = new OrderRequest(); // Empty request&#10;&#10;            // Act &amp; Assert&#10;            mockMvc.perform(post(&quot;/api/v1/orders&quot;)&#10;                    .header(&quot;Authorization&quot;, &quot;Bearer &quot; + userToken)&#10;                    .contentType(MediaType.APPLICATION_JSON)&#10;                    .content(asJsonString(request)))&#10;                    .andExpect(status().isBadRequest());&#10;        }&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Order Status Update Tests&quot;)&#10;    class OrderStatusUpdateTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should successfully update order status&quot;)&#10;        void updateOrderStatus_WithValidStatus_ShouldSucceed() throws Exception {&#10;            // Arrange&#10;            Order order = createAndSaveTestOrder();&#10;&#10;            // Act&#10;            ResultActions result = mockMvc.perform(put(&quot;/api/v1/orders/{id}/status&quot;, order.getId())&#10;                    .header(&quot;Authorization&quot;, &quot;Bearer &quot; + userToken)&#10;                    .param(&quot;status&quot;, OrderStatus.CONFIRMED.name()));&#10;&#10;            // Assert&#10;            result.andExpect(status().isOk())&#10;                    .andExpect(jsonPath(&quot;$.status&quot;, is(OrderStatus.CONFIRMED.name())));&#10;&#10;            // Verify database state&#10;            Order updatedOrder = orderRepository.findById(order.getId()).orElseThrow();&#10;            assertEquals(OrderStatus.CONFIRMED, updatedOrder.getStatus());&#10;        }&#10;    }&#10;&#10;    private User createTestUser() {&#10;        User user = new User();&#10;        user.setUsername(&quot;testuser&quot;);&#10;        user.setEmail(&quot;test@example.com&quot;);&#10;        user.setPassword(passwordEncoder.encode(&quot;password&quot;));&#10;        user.setEnabled(true);&#10;        return userRepository.save(user);&#10;    }&#10;&#10;    private OrderRequest createSampleOrderRequest() {&#10;        OrderRequest request = new OrderRequest();&#10;        request.setUserId(testUser.getId());&#10;        &#10;        OrderRequest.OrderItemRequest item = new OrderRequest.OrderItemRequest();&#10;        item.setProductId(1L);&#10;        item.setQuantity(2);&#10;        item.setUnitPrice(new BigDecimal(&quot;99.99&quot;));&#10;        &#10;        request.setItems(new ArrayList&lt;&gt;(List.of(item)));&#10;        return request;&#10;    }&#10;&#10;    private Order createAndSaveTestOrder() {&#10;        Order order = new Order();&#10;        order.setUser(testUser);&#10;        order.setStatus(OrderStatus.CREATED);&#10;        return orderRepository.save(order);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/performance/OrderProcessingPerformanceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/performance/OrderProcessingPerformanceTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.performance;&#10;&#10;import com.example.ecommerce.dto.OrderRequest;&#10;import com.example.ecommerce.model.Order;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.service.OrderService;&#10;import com.example.ecommerce.service.ProductService;&#10;import com.example.ecommerce.test.BaseIntegrationTest;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Tag;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;&#10;import org.springframework.test.context.jdbc.Sql;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.Duration;&#10;import java.time.Instant;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.*;&#10;import java.util.stream.IntStream;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@Tag(&quot;performance&quot;)&#10;@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)&#10;@Sql({&quot;/data/users.sql&quot;, &quot;/data/products.sql&quot;})&#10;class OrderProcessingPerformanceTest extends BaseIntegrationTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private ProductService productService;&#10;&#10;    private Product testProduct;&#10;    private static final int CONCURRENT_USERS = 50;&#10;    private static final int REQUESTS_PER_USER = 10;&#10;    private static final Duration EXPECTED_RESPONSE_TIME = Duration.ofMillis(500);&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Create a test product with sufficient stock&#10;        testProduct = new Product();&#10;        testProduct.setName(&quot;Performance Test Product&quot;);&#10;        testProduct.setPrice(new BigDecimal(&quot;99.99&quot;));&#10;        testProduct.setStockQuantity(CONCURRENT_USERS * REQUESTS_PER_USER * 2);&#10;        testProduct = productService.createProduct(testProduct);&#10;    }&#10;&#10;    @Test&#10;    void orderCreation_UnderLoad_ShouldMaintainResponseTime() throws InterruptedException {&#10;        // Arrange&#10;        ExecutorService executorService = Executors.newFixedThreadPool(CONCURRENT_USERS);&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch endLatch = new CountDownLatch(CONCURRENT_USERS);&#10;        List&lt;Duration&gt; responseTimes = new CopyOnWriteArrayList&lt;&gt;();&#10;        List&lt;Future&lt;List&lt;Order&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();&#10;&#10;        // Act&#10;        for (int i = 0; i &lt; CONCURRENT_USERS; i++) {&#10;            futures.add(executorService.submit(() -&gt; {&#10;                List&lt;Order&gt; orders = new ArrayList&lt;&gt;();&#10;                startLatch.await(); // Wait for all threads to be ready&#10;                &#10;                for (int j = 0; j &lt; REQUESTS_PER_USER; j++) {&#10;                    Instant start = Instant.now();&#10;                    &#10;                    try {&#10;                        OrderRequest request = createOrderRequest();&#10;                        Order order = orderService.createOrder(request);&#10;                        orders.add(order);&#10;                    } finally {&#10;                        Duration responseTime = Duration.between(start, Instant.now());&#10;                        responseTimes.add(responseTime);&#10;                    }&#10;                    &#10;                    // Add random delay between requests&#10;                    Thread.sleep(ThreadLocalRandom.current().nextLong(50, 150));&#10;                }&#10;                &#10;                endLatch.countDown();&#10;                return orders;&#10;            }));&#10;        }&#10;&#10;        // Start all threads simultaneously&#10;        startLatch.countDown();&#10;        &#10;        // Wait for all threads to complete&#10;        boolean completed = endLatch.await(5, TimeUnit.MINUTES);&#10;        executorService.shutdown();&#10;&#10;        // Assert&#10;        assertTrue(completed, &quot;All requests should complete within timeout&quot;);&#10;        &#10;        // Calculate metrics&#10;        double averageResponseTime = responseTimes.stream()&#10;                .mapToLong(Duration::toMillis)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        long slowResponses = responseTimes.stream()&#10;                .filter(duration -&gt; duration.compareTo(EXPECTED_RESPONSE_TIME) &gt; 0)&#10;                .count();&#10;        &#10;        // Verify results&#10;        assertTrue(averageResponseTime &lt;= EXPECTED_RESPONSE_TIME.toMillis(),&#10;                &quot;Average response time (&quot; + averageResponseTime + &quot;ms) exceeds expected &quot; + EXPECTED_RESPONSE_TIME.toMillis() + &quot;ms&quot;);&#10;        &#10;        assertTrue(slowResponses &lt;= responseTimes.size() * 0.05,&#10;                &quot;More than 5% of responses exceeded expected response time&quot;);&#10;        &#10;        // Verify all orders were created successfully&#10;        long totalOrders = futures.stream()&#10;                .map(future -&gt; {&#10;                    try {&#10;                        return future.get().size();&#10;                    } catch (Exception e) {&#10;                        return 0;&#10;                    }&#10;                })&#10;                .mapToLong(Integer::longValue)&#10;                .sum();&#10;        &#10;        assertEquals(CONCURRENT_USERS * REQUESTS_PER_USER, totalOrders,&#10;                &quot;All orders should be created successfully&quot;);&#10;    }&#10;&#10;    @Test&#10;    void productSearch_UnderLoad_ShouldMaintainPerformance() throws InterruptedException {&#10;        // Arrange&#10;        int numSearches = 1000;&#10;        ExecutorService executorService = Executors.newFixedThreadPool(20);&#10;        List&lt;Duration&gt; responseTimes = new CopyOnWriteArrayList&lt;&gt;();&#10;        CountDownLatch endLatch = new CountDownLatch(numSearches);&#10;&#10;        // Act&#10;        IntStream.range(0, numSearches).forEach(i -&gt; &#10;            executorService.submit(() -&gt; {&#10;                try {&#10;                    Instant start = Instant.now();&#10;                    productService.searchProducts(&quot;Test&quot;, null);&#10;                    responseTimes.add(Duration.between(start, Instant.now()));&#10;                } finally {&#10;                    endLatch.countDown();&#10;                }&#10;            })&#10;        );&#10;&#10;        // Wait for completion&#10;        boolean completed = endLatch.await(2, TimeUnit.MINUTES);&#10;        executorService.shutdown();&#10;&#10;        // Assert&#10;        assertTrue(completed, &quot;All searches should complete within timeout&quot;);&#10;        &#10;        double averageResponseTime = responseTimes.stream()&#10;                .mapToLong(Duration::toMillis)&#10;                .average()&#10;                .orElse(0.0);&#10;                &#10;        assertTrue(averageResponseTime &lt;= 100.0,&#10;                &quot;Average search response time should be under 100ms&quot;);&#10;    }&#10;&#10;    private OrderRequest createOrderRequest() {&#10;        OrderRequest request = new OrderRequest();&#10;        request.setUserId(1L); // From users.sql&#10;        &#10;        OrderRequest.OrderItemRequest item = new OrderRequest.OrderItemRequest();&#10;        item.setProductId(testProduct.getId());&#10;        item.setQuantity(2);&#10;        &#10;        request.getItems().add(item);&#10;        return request;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/regression/OrderWorkflowRegressionTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/regression/OrderWorkflowRegressionTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.regression;&#10;&#10;import com.example.ecommerce.dto.OrderRequest;&#10;import com.example.ecommerce.dto.ProductRequest;&#10;import com.example.ecommerce.model.Order;&#10;import com.example.ecommerce.model.OrderStatus;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.service.OrderService;&#10;import com.example.ecommerce.service.ProductService;&#10;import com.example.ecommerce.test.BaseIntegrationTest;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Tag;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.test.context.jdbc.Sql;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.awaitility.Awaitility.await;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@Tag(&quot;regression&quot;)&#10;@Sql({&quot;/data/users.sql&quot;, &quot;/data/products.sql&quot;})&#10;class OrderWorkflowRegressionTest extends BaseIntegrationTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private ProductService productService;&#10;&#10;    private Product testProduct;&#10;    private OrderRequest orderRequest;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Create a test product with stock&#10;        ProductRequest productRequest = new ProductRequest();&#10;        productRequest.setName(&quot;Test Product&quot;);&#10;        productRequest.setPrice(new BigDecimal(&quot;99.99&quot;));&#10;        productRequest.setStockQuantity(10);&#10;        testProduct = productService.createProduct(Product.fromRequest(productRequest));&#10;&#10;        // Prepare order request&#10;        orderRequest = new OrderRequest();&#10;        orderRequest.setUserId(1L); // Assuming user exists from users.sql&#10;        OrderRequest.OrderItemRequest item = new OrderRequest.OrderItemRequest();&#10;        item.setProductId(testProduct.getId());&#10;        item.setQuantity(2);&#10;        orderRequest.getItems().add(item);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Complete Order Workflow - Happy Path&quot;)&#10;    void completeOrderWorkflow_HappyPath_ShouldSucceed() {&#10;        // Step 1: Create Order&#10;        Order order = orderService.createOrder(orderRequest);&#10;        assertNotNull(order.getId());&#10;        assertEquals(OrderStatus.CREATED, order.getStatus());&#10;&#10;        // Step 2: Verify Stock Updated&#10;        Product updatedProduct = productService.getProduct(testProduct.getId()).orElseThrow();&#10;        assertEquals(8, updatedProduct.getStockQuantity());&#10;&#10;        // Step 3: Process Payment&#10;        Order paidOrder = orderService.processPayment(order.getId(), &quot;CREDIT_CARD&quot;);&#10;        assertEquals(OrderStatus.PAID, paidOrder.getStatus());&#10;&#10;        // Step 4: Confirm Delivery&#10;        Order deliveredOrder = orderService.confirmDelivery(order.getId());&#10;        assertEquals(OrderStatus.DELIVERED, deliveredOrder.getStatus());&#10;&#10;        // Step 5: Complete Order&#10;        Order completedOrder = orderService.updateOrderStatus(order.getId(), OrderStatus.COMPLETED);&#10;        assertEquals(OrderStatus.COMPLETED, completedOrder.getStatus());&#10;        assertNotNull(completedOrder.getCompletedAt());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Order Cancellation Workflow&quot;)&#10;    void orderCancellationWorkflow_ShouldRestoreStock() {&#10;        // Step 1: Create Order&#10;        Order order = orderService.createOrder(orderRequest);&#10;        int initialStock = testProduct.getStockQuantity();&#10;&#10;        // Step 2: Cancel Order&#10;        boolean cancelled = orderService.cancelOrder(order.getId());&#10;        assertTrue(cancelled);&#10;&#10;        // Step 3: Verify Stock Restored&#10;        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -&gt; {&#10;            Product updatedProduct = productService.getProduct(testProduct.getId()).orElseThrow();&#10;            assertEquals(initialStock, updatedProduct.getStockQuantity());&#10;        });&#10;&#10;        // Step 4: Verify Order Status&#10;        Order cancelledOrder = orderService.getOrder(order.getId()).orElseThrow();&#10;        assertEquals(OrderStatus.CANCELLED, cancelledOrder.getStatus());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Order Return Workflow&quot;)&#10;    void orderReturnWorkflow_ShouldHandleRefundAndStock() {&#10;        // Step 1: Create and Complete Order&#10;        Order order = orderService.createOrder(orderRequest);&#10;        order = orderService.processPayment(order.getId(), &quot;CREDIT_CARD&quot;);&#10;        order = orderService.confirmDelivery(order.getId());&#10;&#10;        // Step 2: Initiate Return&#10;        Order returnedOrder = orderService.initiateReturn(order.getId(), &quot;Defective product&quot;);&#10;        assertEquals(OrderStatus.RETURNED, returnedOrder.getStatus());&#10;&#10;        // Step 3: Verify Stock Updated&#10;        await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -&gt; {&#10;            Product updatedProduct = productService.getProduct(testProduct.getId()).orElseThrow();&#10;            assertEquals(10, updatedProduct.getStockQuantity());&#10;        });&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Multiple Order Processing Workflow&quot;)&#10;    void multipleOrderProcessing_ShouldMaintainConsistency() {&#10;        // Step 1: Create Multiple Orders&#10;        Order order1 = orderService.createOrder(orderRequest);&#10;        Order order2 = orderService.createOrder(orderRequest);&#10;&#10;        // Step 2: Process Orders in Different States&#10;        orderService.processPayment(order1.getId(), &quot;CREDIT_CARD&quot;);&#10;        orderService.cancelOrder(order2.getId());&#10;&#10;        // Step 3: Verify Final States&#10;        Order finalOrder1 = orderService.getOrder(order1.getId()).orElseThrow();&#10;        Order finalOrder2 = orderService.getOrder(order2.getId()).orElseThrow();&#10;&#10;        assertEquals(OrderStatus.PAID, finalOrder1.getStatus());&#10;        assertEquals(OrderStatus.CANCELLED, finalOrder2.getStatus());&#10;&#10;        // Step 4: Verify Stock Consistency&#10;        Product finalProduct = productService.getProduct(testProduct.getId()).orElseThrow();&#10;        assertEquals(8, finalProduct.getStockQuantity());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/service/ConcurrentOperationsTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/service/ConcurrentOperationsTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.service;&#10;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.repository.ProductRepository;&#10;import com.example.ecommerce.test.BaseIntegrationTest;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.test.context.jdbc.Sql;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;&#10;@Sql(&quot;/data/products.sql&quot;)&#10;class ConcurrentOperationsTest extends BaseIntegrationTest {&#10;&#10;    @Autowired&#10;    private ProductService productService;&#10;&#10;    @Autowired&#10;    private ProductRepository productRepository;&#10;&#10;    private Product testProduct;&#10;    private static final int THREAD_COUNT = 10;&#10;    private static final int STOCK_DECREASE_PER_THREAD = 2;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        testProduct = new Product();&#10;        testProduct.setName(&quot;Concurrent Test Product&quot;);&#10;        testProduct.setPrice(new BigDecimal(&quot;99.99&quot;));&#10;        testProduct.setStockQuantity(THREAD_COUNT * STOCK_DECREASE_PER_THREAD);&#10;        testProduct = productRepository.save(testProduct);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle concurrent stock updates correctly&quot;)&#10;    void concurrentStockUpdates_ShouldMaintainConsistency() throws InterruptedException {&#10;        // Arrange&#10;        ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);&#10;        List&lt;Exception&gt; exceptions = new ArrayList&lt;&gt;();&#10;&#10;        // Act&#10;        for (int i = 0; i &lt; THREAD_COUNT; i++) {&#10;            executorService.submit(() -&gt; {&#10;                try {&#10;                    startLatch.await(); // Wait for all threads to be ready&#10;                    productService.updateStock(testProduct.getId(), -STOCK_DECREASE_PER_THREAD);&#10;                } catch (Exception e) {&#10;                    exceptions.add(e);&#10;                } finally {&#10;                    endLatch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        // Start all threads simultaneously&#10;        startLatch.countDown();&#10;        &#10;        // Wait for all threads to complete&#10;        boolean completed = endLatch.await(10, TimeUnit.SECONDS);&#10;        executorService.shutdown();&#10;&#10;        // Assert&#10;        assertEquals(0, exceptions.size(), &quot;No exceptions should occur during concurrent updates&quot;);&#10;        assertEquals(true, completed, &quot;All threads should complete within timeout&quot;);&#10;&#10;        // Verify final stock quantity&#10;        Product updatedProduct = productRepository.findById(testProduct.getId()).orElseThrow();&#10;        assertEquals(0, updatedProduct.getStockQuantity(),&#10;            &quot;Stock should be zero after all concurrent updates&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle concurrent order creation correctly&quot;)&#10;    void concurrentOrderCreation_WithLimitedStock_ShouldMaintainConsistency() throws InterruptedException {&#10;        // Arrange&#10;        int initialStock = 5; // Limited stock&#10;        testProduct.setStockQuantity(initialStock);&#10;        productRepository.save(testProduct);&#10;&#10;        ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);&#10;        List&lt;Boolean&gt; successfulReservations = new ArrayList&lt;&gt;();&#10;&#10;        // Act&#10;        for (int i = 0; i &lt; THREAD_COUNT; i++) {&#10;            executorService.submit(() -&gt; {&#10;                try {&#10;                    startLatch.await();&#10;                    boolean reserved = productService.reserveStock(testProduct.getId(), 1);&#10;                    synchronized (successfulReservations) {&#10;                        successfulReservations.add(reserved);&#10;                    }&#10;                } catch (Exception e) {&#10;                    // Log exception&#10;                } finally {&#10;                    endLatch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        startLatch.countDown();&#10;        endLatch.await(10, TimeUnit.SECONDS);&#10;        executorService.shutdown();&#10;&#10;        // Assert&#10;        long successfulCount = successfulReservations.stream().filter(success -&gt; success).count();&#10;        assertEquals(initialStock, successfulCount,&#10;            &quot;Number of successful reservations should match initial stock&quot;);&#10;&#10;        Product finalProduct = productRepository.findById(testProduct.getId()).orElseThrow();&#10;        assertEquals(0, finalProduct.getStockQuantity(),&#10;            &quot;Stock should be zero after all successful reservations&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle concurrent cache updates correctly&quot;)&#10;    void concurrentCacheUpdates_ShouldMaintainConsistency() throws InterruptedException {&#10;        // Arrange&#10;        ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);&#10;        CountDownLatch startLatch = new CountDownLatch(1);&#10;        CountDownLatch endLatch = new CountDownLatch(THREAD_COUNT);&#10;        List&lt;Product&gt; retrievedProducts = new ArrayList&lt;&gt;();&#10;&#10;        // Prime the cache&#10;        productService.getProduct(testProduct.getId());&#10;&#10;        // Act&#10;        for (int i = 0; i &lt; THREAD_COUNT; i++) {&#10;            final int updateValue = i;&#10;            executorService.submit(() -&gt; {&#10;                try {&#10;                    startLatch.await();&#10;                    // Update product&#10;                    testProduct.setStockQuantity(updateValue);&#10;                    Product updated = productService.updateProduct(testProduct.getId(), testProduct);&#10;                    // Read product (should be from cache)&#10;                    productService.getProduct(testProduct.getId())&#10;                        .ifPresent(retrievedProducts::add);&#10;                } catch (Exception e) {&#10;                    // Log exception&#10;                } finally {&#10;                    endLatch.countDown();&#10;                }&#10;            });&#10;        }&#10;&#10;        startLatch.countDown();&#10;        endLatch.await(10, TimeUnit.SECONDS);&#10;        executorService.shutdown();&#10;&#10;        // Assert&#10;        assertEquals(THREAD_COUNT, retrievedProducts.size(),&#10;            &quot;All threads should retrieve a product&quot;);&#10;        &#10;        // Verify cache consistency&#10;        Product finalCachedProduct = productService.getProduct(testProduct.getId()).orElseThrow();&#10;        Product finalDbProduct = productRepository.findById(testProduct.getId()).orElseThrow();&#10;        assertEquals(finalDbProduct.getStockQuantity(), finalCachedProduct.getStockQuantity(),&#10;            &quot;Cache and DB should be consistent&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/service/ProductServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/service/ProductServiceTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.service;&#10;&#10;import com.example.ecommerce.exception.InsufficientStockException;&#10;import com.example.ecommerce.model.Product;&#10;import com.example.ecommerce.repository.ProductRepository;&#10;import com.example.ecommerce.service.impl.ProductServiceImpl;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Nested;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.context.ApplicationEventPublisher;&#10;&#10;import java.math.BigDecimal;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class ProductServiceTest {&#10;&#10;    @Mock&#10;    private ProductRepository productRepository;&#10;&#10;    @Mock&#10;    private ApplicationEventPublisher eventPublisher;&#10;&#10;    @InjectMocks&#10;    private ProductServiceImpl productService;&#10;&#10;    private Product testProduct;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        testProduct = new Product();&#10;        testProduct.setId(1L);&#10;        testProduct.setName(&quot;Test Product&quot;);&#10;        testProduct.setPrice(new BigDecimal(&quot;99.99&quot;));&#10;        testProduct.setStockQuantity(10);&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Stock Management Tests&quot;)&#10;    class StockManagementTests {&#10;        &#10;        @Test&#10;        @DisplayName(&quot;Should successfully update stock when sufficient quantity available&quot;)&#10;        void updateStock_WithSufficientQuantity_ShouldSucceed() {&#10;            // Arrange&#10;            when(productRepository.findById(1L)).thenReturn(Optional.of(testProduct));&#10;            when(productRepository.save(any(Product.class))).thenReturn(testProduct);&#10;&#10;            // Act&#10;            boolean result = productService.updateStock(1L, -5);&#10;&#10;            // Assert&#10;            assertTrue(result);&#10;            assertEquals(5, testProduct.getStockQuantity());&#10;            verify(eventPublisher).publishEvent(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should throw exception when insufficient stock&quot;)&#10;        void updateStock_WithInsufficientQuantity_ShouldThrowException() {&#10;            // Arrange&#10;            when(productRepository.findById(1L)).thenReturn(Optional.of(testProduct));&#10;&#10;            // Act &amp; Assert&#10;            assertThrows(InsufficientStockException.class,&#10;                () -&gt; productService.updateStock(1L, -15));&#10;            &#10;            verify(productRepository, never()).save(any());&#10;            verify(eventPublisher, never()).publishEvent(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle concurrent stock updates correctly&quot;)&#10;        void updateStock_WithConcurrentAccess_ShouldHandleCorrectly() {&#10;            // Arrange&#10;            when(productRepository.findById(1L)).thenReturn(Optional.of(testProduct));&#10;            when(productRepository.save(any(Product.class))).thenReturn(testProduct);&#10;&#10;            // Act&#10;            boolean result1 = productService.updateStock(1L, -3);&#10;            boolean result2 = productService.updateStock(1L, -4);&#10;&#10;            // Assert&#10;            assertTrue(result1);&#10;            assertTrue(result2);&#10;            assertEquals(3, testProduct.getStockQuantity());&#10;            verify(eventPublisher, times(2)).publishEvent(any());&#10;        }&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Product Management Tests&quot;)&#10;    class ProductManagementTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should validate product price is greater than zero&quot;)&#10;        void createProduct_WithInvalidPrice_ShouldThrowException() {&#10;            // Arrange&#10;            Product invalidProduct = new Product();&#10;            invalidProduct.setPrice(BigDecimal.ZERO);&#10;&#10;            // Act &amp; Assert&#10;            assertThrows(IllegalArgumentException.class,&#10;                () -&gt; productService.createProduct(invalidProduct));&#10;            &#10;            verify(productRepository, never()).save(any());&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should successfully create valid product&quot;)&#10;        void createProduct_WithValidProduct_ShouldSucceed() {&#10;            // Arrange&#10;            when(productRepository.save(any(Product.class))).thenReturn(testProduct);&#10;&#10;            // Act&#10;            Product result = productService.createProduct(testProduct);&#10;&#10;            // Assert&#10;            assertNotNull(result);&#10;            assertEquals(testProduct.getName(), result.getName());&#10;            verify(eventPublisher).publishEvent(any());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/test/BaseIntegrationTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/e-commerce-service/src/test/java/com/example/ecommerce/test/BaseIntegrationTest.java" />
              <option name="updatedContent" value="package com.example.ecommerce.test;&#10;&#10;import com.example.ecommerce.config.TestContainersConfig;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.TestInstance;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;import org.springframework.context.annotation.Import;&#10;import org.springframework.test.context.ActiveProfiles;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;@SpringBootTest&#10;@AutoConfigureMockMvc&#10;@ActiveProfiles(&quot;test&quot;)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;@Import(TestContainersConfig.class)&#10;@Transactional&#10;public abstract class BaseIntegrationTest {&#10;&#10;    @Autowired&#10;    protected MockMvc mockMvc;&#10;&#10;    @Autowired&#10;    protected ObjectMapper objectMapper;&#10;&#10;    protected String asJsonString(final Object obj) {&#10;        try {&#10;            return objectMapper.writeValueAsString(obj);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(e);&#10;        }&#10;    }&#10;    &#10;    // Add more helper methods for testing&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>